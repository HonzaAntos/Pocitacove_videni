clear all;
close all;
clc;
% Read the original image
img = imread('bottle.JPG'); % Replace 'bottle.JPG' with your image file name
% Convert to grayscale if necessary
if size(img, 3) == 3
    img_gray = rgb2gray(img);
else
    img_gray = img;
end
% Specify xmin and xmax positions
xmin = 470; % Updated xmin position
xmax = 700; % Updated xmax position
% Define the step size for drawing vertical lines
step = 10;
% Initialize arrays to store edges for each line
all_left_points = cell(1, floor((xmax - xmin) / step) + 1);
all_right_points = cell(1, floor((xmax - xmin) / step) + 1);
% Initialize arrays to store intersections
b1 = cell(1, floor((xmax - xmin) / step) + 1); % Store intersections closer to middle_y
b2 = cell(1, floor((xmax - xmin) / step) + 1); % Store intersections farther from middle_y
% Define the convolutional mask
conv_mask = [1 1 1; 0 0 -1 -1 -1];
% Apply the convolutional mask to find gradients
gradient_img = conv2(double(img_gray), conv_mask, 'same');
% Threshold the gradient magnitude to obtain edges
threshold = 22; % You can adjust this threshold as needed
edges = abs(gradient_img) > threshold;
% Calculate the middle of the Y-axis
middle_y = round(size(img, 1) / 2);
% Create a new figure for the original image with vertical lines
figure;
imshow(img_gray);
hold on;
% Draw additional vertical lines with a step size of 10 pixels
for x = xmin:step:xmax
    line([x, x], [1, size(img_gray, 1)], 'Color', 'm', 'LineWidth', 1);
    
    % Find edges for the current vertical line
    left_line_points = [];
    right_line_points = [];
    
    for i = 1:size(edges, 1)
        row = edges(i, :);
        if x >= 1 && x <= size(row, 2)
            if row(x) == 1
                % To find the right edge, you can search to the left and right
                left_search_range = max(1, x - step):min(size(row, 2), x + step);
                for j = left_search_range
                    if row(j) == 0
                        left_line_points = [left_line_points; [i, j]];
                        break;
                    end
                end
                for j = fliplr(left_search_range) % Search in the opposite direction for the right intersection
                    if row(j) == 0
                        right_line_points = [right_line_points; [i, j]];
                        break;
                    end
                end
            end
        end
    end
    
    % Store edges for the current line
    all_left_points{end} = left_line_points;
    all_right_points{end} = right_line_points;
    
    % Find the intersection closest to middle_y and store in b1, and the other in b2
    if ~isempty(left_line_points) || ~isempty(right_line_points)
        middle_y_diff = abs((left_line_points(:, 1) + right_line_points(:, 1)) / 2 - middle_y);
        min_index = find(middle_y_diff == min(middle_y_diff));
        b1{end} = [b1{end}; left_line_points(min_index, :); right_line_points(min_index, :)];
        b2{end} = [b2{end}; left_line_points(setdiff(1:size(left_line_points, 1), min_index), :); ...
            right_line_points(setdiff(1:size(right_line_points, 1), min_index), :)];
    end
end
title('Original Image with Additional Vertical Lines and Intersections');
hold off;
% Display the edge image in a new figure
figure;
imshow(edges);
title('Edge Image');
% Display b1 and b2
figure;
imshow(img_gray);
hold on;
for i = 1:length(b1)
    if ~isempty(b1{i})
        plot(b1{i}(:, 2), b1{i}(:, 1), 'go', 'MarkerSize', 5); % Green for b1
    end
    if ~isempty(b2{i})
        plot(b2{i}(:, 2), b2{i}(:, 1), 'bo', 'MarkerSize', 5); % Blue for b2
    end
end
title('Intersections: Green (b1) and Blue (b2)');
hold off;
